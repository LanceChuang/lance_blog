<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Lance Wonderland</title>
    <link>http://lancechuang.github.io/lance_blog/tags/leetcode/</link>
    <description>Recent content in Leetcode on Lance Wonderland</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Tue, 06 Nov 2018 00:00:00 -0800</lastBuildDate>
    
	<atom:link href="http://lancechuang.github.io/lance_blog/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>124. Binary Tree Maximum Path Sum</title>
      <link>http://lancechuang.github.io/lance_blog/post/2018-11-06/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 -0800</pubDate>
      
      <guid>http://lancechuang.github.io/lance_blog/post/2018-11-06/</guid>
      <description>題目來自Leetcode
題目 Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
 1 / \ 2 3  Output: 6 Example 2:</description>
    </item>
    
    <item>
      <title>Minimum Path Sum</title>
      <link>http://lancechuang.github.io/lance_blog/post/2018-10-07/</link>
      <pubDate>Sun, 07 Oct 2018 00:00:00 -0700</pubDate>
      
      <guid>http://lancechuang.github.io/lance_blog/post/2018-10-07/</guid>
      <description>Description  Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizesthe sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.
  0 / \ -3 9 / / -10 5  DP想法:</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://lancechuang.github.io/lance_blog/post/2018-09-30/</link>
      <pubDate>Sun, 30 Sep 2018 00:00:00 -0700</pubDate>
      
      <guid>http://lancechuang.github.io/lance_blog/post/2018-09-30/</guid>
      <description>Description  Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</description>
    </item>
    
    <item>
      <title>2 Sum - Unique Pair</title>
      <link>http://lancechuang.github.io/lance_blog/post/2018-09-11/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 -0700</pubDate>
      
      <guid>http://lancechuang.github.io/lance_blog/post/2018-09-11/</guid>
      <description>Description Given an array of integers, find how many unique pairs in the array such that their sum is equal to a specific target number. Please return the number of pairs. Example Given nums = [1,1,2,45,46,46], target = 47 return 2 1 + 46 = 47 2 + 45 = 47  想法：要找到所有的不同組合，所以不能用一般hash的方式
這邊使用 2 pointer解
 sort arry, 小的部分會在左邊，大的會在右邊 設定while條件為left &amp;lt; right，當兩個pointer指的數相加大於target，將右指針向內縮; 若小於target，則往右移動左指針 當pointer數加起來等於target，count ++, 左右指針向內縮，因為array有可能會有重複數字且題目是要unique pair，所以要做去重的動作： 若left指向的數和上個一樣，則再往右跑; 若right指向數和上個一樣，則向左跑  https://repl.</description>
    </item>
    
    <item>
      <title>394. Decode String - Google Amazon Bloomberg Oracle</title>
      <link>http://lancechuang.github.io/lance_blog/post/2018-08-26/</link>
      <pubDate>Wed, 20 Apr 2016 00:00:00 -0700</pubDate>
      
      <guid>http://lancechuang.github.io/lance_blog/post/2018-08-26/</guid>
      <description>題目來自Leetcode
題目  The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description>
    </item>
    
  </channel>
</rss>